package org.penforge.backend.statistics;

import lombok.Data;
import lombok.AllArgsConstructor;
import org.penforge.backend.pentestReport.PentestReportRepository;
import org.springframework.stereotype.Service;
import org.penforge.backend.pentestReport.PentestReport;
import org.penforge.backend.pentestReport.PortData;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

@Service
@Data
@AllArgsConstructor
public class PentestStatisticsService {

    private final PentestReportRepository pentestReportRepository;

    public StatisticsData calculateStatistics(String userId) {

        List<PentestReport> reports = pentestReportRepository.findAllByUserId(userId)
                .orElse(List.of());

        Set<String> uniqueTargets = new HashSet<>();
        Set<String> vulnerableTargets = new HashSet<>();

        int totalOpenPorts = 0;
        int closedPorts = 0;
        int filteredPorts = 0;

        OpenPorts openPorts = new OpenPorts(0, 0, 0, 0, 0, 0, 0, 0);

        for (PentestReport report : reports) {
            uniqueTargets.add(report.getTargetIP());
            if (report.getPortData() != null) {
                for (PortData portData : report.getPortData()) {
                    switch (portData.getPortService()) {
                        case "http":
                            openPorts.setHttp(openPorts.getHttp() + 1);
                            break;
                        case "smtp":
                            openPorts.setSmtp(openPorts.getSmtp() + 1);
                            break;
                        case "ftp":
                            openPorts.setFtp(openPorts.getFtp() + 1);
                            break;
                        case "ssh":
                            openPorts.setSsh(openPorts.getSsh() + 1);
                            break;
                        case "smb":
                            openPorts.setSmb(openPorts.getSmb() + 1);
                            break;
                        case "dns":
                            openPorts.setDns(openPorts.getDns() + 1);
                            break;
                        case "telnet":
                            openPorts.setTelnet(openPorts.getTelnet() + 1);
                            break;
                        case "tftp":
                            openPorts.setTftp(openPorts.getTftp() + 1);
                            break;
                    }
                    switch (portData.getPortState()) {
                        case "open":
                            totalOpenPorts++;
                            break;
                        case "closed":
                            closedPorts++;
                            break;
                        case "filtered":
                            filteredPorts++;
                            break;
                    }
                }
            }
            if (report.getCredentials() != null && !report.getCredentials().isEmpty()) {
                vulnerableTargets.add(report.getTargetIP());
            }
        }

        int totalTargets = uniqueTargets.size();
        int totalVulnerableTargets = vulnerableTargets.size();
        int totalTests = reports.size();

        PortStatus portStatus = new PortStatus(closedPorts, filteredPorts, totalOpenPorts);

        return new StatisticsData(totalTargets, totalVulnerableTargets, totalOpenPorts, totalTests, portStatus, openPorts);
    }

}
